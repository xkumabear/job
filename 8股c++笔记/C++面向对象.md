# 面向对象

****

三大特性：**封装**、**继承**、**多态**

## 类和对象

### 封装

封装的意义：

- 将属性和行为**作为一个整体**来表现。
- 对属性和行为加以**权限控制**

访问权限的区别：

- public：成员 类内、类外可以访问
- protected：成员 类内可以访问，类外不可访问
- private：成员 类内可以访问，类外不可访问
  - 便于控制读写
  - 对于写可以检测数据的有效性

保护与私有间的区别，保护权限，子继承可以访问，私有，子继承不可访问

### 继承

目的利用继承减少代码重复

语法： class 子类：继承方式  父类

子类   也称为  **派生类**    父类 也称为 **基类**

**继承方式**：

- 公共继承
- 保护继承
- 私有继承

**继承中的对象模型：**

**继承中同名成员处理方式：**

- 访问子类同名：直接访问
- 访问父类同名：加作用域

**多继承语法：**允许一个类继承多个类

语法：class  子类：继承方式  父类1，继承方式  父类2,…

注意：通过加作用域来区分同名成员。

菱形继承：两个派生类继承同一个基类，又有一个类继承该两个派生类，会引发二义性；	

- 解决方法：虚继承，将原基类，变为虚基类。	

### 多态

优点：

1. 代码组织结构清晰

2. 可读性强

3. 利于前期和后期的扩展与维护

   

   多态则为了避免在父类里大量重载引起代码臃肿且难于维护。

- 静态多态：如函数重载，运算符重载等复用函数名

  - 函数地址早绑定，编译阶段确定函数地址

- 动态多态：派生类，和虚函数实现运行时多态

  - 地址晚绑定，运行阶段确定函数地址
  - 使用虚函数：virtual
  - 满足条件：
    1. 有继承关系
    2. 子类重新父类虚函数，【重写：返回值，函数名，参数列表，完全相同】
  - 使用方法：**父类的指针或者引用  指向子类对象。**

- 纯虚函数和抽象类

  - 在使用多态时，通常父类中的虚函数的实现是无意义的，主要都是调用子类重新的内容
  - 因此将虚函数改为纯虚函数
  - 虚函数语法：virtual 返回值类型  函数名  （参数列表）= 0；
  - 当类中有了纯虚函数，这个类也就被称为抽象类

  抽象类特点：

  - 无法实例化对象
  - 子类必须重写抽象类中的纯虚函数，否则也属于抽象类

- 虚析构和纯虚析构

  - 多态使用时，若子类有属性开辟在堆区，那父类指针在释放时是无法调用到子类的析构代码的
  - 解决办法：将父类中的析构函数改为**虚析构**或**纯虚析构**
  - 二者共性：
    - 可以解决父类指针释放子对象问题
    - 都需要有具体的函数实现
  - 区别：
    - 如果是纯虚析构，该类属于抽象类，无法实力化对象。
  - 语法：
    - 虚析构：virtual ~类名（）{}
    - 纯虚析构：virtual ~类名（）= 0；类名：：~类名（）{}；

### 类的初始化和清理

#### 构造函数

def:编译器自动调用，用于创建对象时，初始化操作。

语法：

1. **没有返回值**，也不写void。
2. 函数名与类名相同。
3. 构造函数可以有参数，因此**可以发生重载**。
4. 自动调用，且只调用一次。

调用：

- 拷贝构造函数：person(const person &p){```}
  - 使用创建完毕的对象，初始化新对象
  - 值传递的方式给函数参数传值
  - 以值方式返回局部对象
- 括号法：person p(10)
- 显式法：person p = person(10)
- 隐式转化法：person p = 10

#### 析构函数

def:对象销毁前自动调用，执行清理操作。

语法：

1. 没有返回值，不写void。
2. 函数名与类名相同，在名称前加符号**~**
3. **不可以**有参，因此**不可以**发生重载。
4. 销毁前自动调用，且只调用一次。

如果不实现构造析构，则编辑器会提供空函数作为构造和析构（构造与析构是必须的）默认情况下有：

- 默认构造（空）
- 默认析构（空）
- 默认拷贝构造（对属性进行值拷贝）

#### 初始化列表

用来初始化属性值

语法：构造函数（）：属性1（值），属性2（值）{}

#### 静态成员

静态成员变量：

- 所有成员共享一份数据。
- 编译阶段分配内存。
- 类内声明，类外初始化。

静态成员函数

- 对象共享同一个函数。
- 静态成员函数只能访问静态成员变量。
- 静态属性和成员都是有访问权限的。

调用方法：

- 通过对象访问
- 通过类名访问  person::func()   person::name  

#### C++对象模型和this指针

- **成员变量和成员函数分开存储**

- 只有非静态成员变量才属于类的对象上，函数与静态成员不属于类的对象。
- 空对象占用内存空间为1【目的：区分空对象】
- 每个空对象有各自的地址

多个同类的对象共用同一块代码空间，

this指针指向被调用的成员函数所属的对象【隐含的，不需要定义】【本质：指针常量】

- 解决命名冲突
- 返回对象本身用*this(可用于链式)

#### const修饰成员函数

**常函数：**

- 成员函数后加const  称为常函数
- 常函数内不可修改成员属性
- 成员属性声明时加关键字mutable ，在常函数中依然可以修改

**常对象：**

- 声明对象前加const，称该对象为常对象
- 常对象只能调用常函数

#### 友元friend

目的：让一个函数或类访问另一个类中私有成员

实现：

1. 全局函数做友元
2. 类做友元
3. 成员函数做友元

#### 运算符重载

- 全局函数重载
- 成员函数重载

#### 深拷贝与浅拷贝【重点】

浅拷贝：简单的赋值拷贝操作。

深拷贝：在**堆区重新申请空间**，进行拷贝操作。

## 结构体和类的区别

在c++中struct 与 class的唯一区别在于默认的访问权限不同，

- struct：默认为公共；
- class：默认为私有；