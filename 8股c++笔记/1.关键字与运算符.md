

#### 1 .  const：

const 关键字，被修饰的值，是只读变量。**必须在定义的时候就赋初值**！

#### constexpr变量

复杂系统中很难分辨⼀个初始值是不是常量表达式，可以**将变量声明为constexpr类型，由 编译器来验证变量的值是否是⼀个常量表达式。**

**必须使⽤常量初始化**

constexpr声明中定义了⼀个指针，**constexpr仅对指针有效，和所指对象⽆关**

constexpr函数： constexpr函数是指能**⽤于常量表达式的函数**。**返回类型和所有形参类型都是字⾯值类型**，函数体**有且只有⼀条return语句**。

为了可以在编译过程展开，**constexpr函数被隐式转换成了内联函数**。 constexpr和内联函数可以在程序中多次定义，⼀般定义在头⽂件。

constexpr 构造函数：

​	**构造函数不能说const，但字⾯值常量类的构造函数可以是constexpr。**

​	constexpr构造函数必须有⼀个空的函数体，即**所有成员变量的初始化都放到初始化列表 中。对象调⽤的成员函数必须使⽤ constexpr 修饰** 

constexpr的好处：

1. 为⼀些不能修改数据提供保障，写成变量则就有被意外修改的风险。 
2. 有些场景，**编译器可以在编译期对constexpr的代码进⾏优化，提⾼效率。**
3.  **相⽐宏来说，没有额外的开销，但更安全可靠**

#### constexpr 和 const

1. const 表⽰**“只读”的语义**，constexpr 表⽰**“常量”的语义**
2. constexpr 只能定义**编译期常量**，⽽ **const 可以定义编译期常量，也可以定义运⾏期常量。**
3. 将⼀个成员函数标记为constexpr，则顺带也将它标记为了const。如果你将⼀个变量标记 为constexpr，则同样它是const的。但相反并不成⽴

```c++
constexpr int *p = nullptr; //常量指针 顶层const
const int *q = nullptr; //指向常量的指针， 底层const
int *const q = nullptr; //顶层const
```



若要**修改const修饰的变量的值，需要加上关键字volatile**； 

若想要**修改const成员函数中某些与类状态⽆关的数据成员，可以使⽤mutable关键字来修 饰这个数据成员**



#### volatile：

与const绝对对⽴的，是类型修饰符，

⽤该关键字声明的变量表⽰ 该变量随时可能发⽣变化，与该变量有关的运算，**不要进⾏编译优化；会从内存中重新装载 内容，⽽不是直接从寄存器拷贝内容。**

作用：指令关键字，**确保本条指令不会因编译器的优化⽽省略，且要求每次直接读值，保证对特殊 地址的稳定访问**

例子：

```c++
//空循环：
for(volatile int i=0; i<100000; i++); // 它会执⾏，不会被优化掉
```

#### **extern**：

​	定义：**声明外部变量**【在函数或者⽂件外部定义的全局变量】

##### 1.1  常量指针  

​	底层 const。c++

​	一个指向一个只读的对象的指针。

​	常量指针强调的是指针对其所指对象的不可改变性

##### 1.2 指针常量

​	顶层 const

​	一个常量指针 ， 该指针只读，且只在定义的时候进行初始化。

​	指 针常量强调的是指针的不可改变性。

顶层const：指针本⾝是常量； 底层const：指针所指的对象是常量；

#### static 

static 作⽤：**实现多个对象之间的数据共享 + 隐藏**，并且**使⽤静态成员还不会破坏隐藏原则**；默 认初始化为0

#### const和static的区别



![image-20230215162705956](C:\Users\qq130\AppData\Roaming\Typora\typora-user-images\image-20230215162705956.png)





#### 2. define 和 typedef

##### define：

1. 只是简单的字符串替换，**没有类型检查** 
2.  是**在编译的预处理阶段起作⽤** 
3.  可以⽤来防⽌头⽂件重复引⽤
4. **不分配内存**，给出的是⽴即数，有多少次使⽤就进⾏多少次替换
5. 不安全

**typedef：**

1.  有对应的数据类型，是**要进⾏类型判断**的 
2.  是在编译、运⾏的时候起作⽤    ？
3.  **在静态存储区中分配空间**，在程序运⾏过程中内存中**只有⼀个拷贝**

### 类型别名

定义某种类型的同义词

1. 使用 `typedef`
2. 使用`using SI  =  Sales_item;`  新标准

##### inline：

1. inline是先将内联函数编译完成⽣成了函数体直接插⼊被调⽤的地⽅，减少了压栈，跳转和 返回的操作。没有普通函数调⽤时的额外开销；
2. 内联函数是⼀种特殊的函数，会进⾏类型检查； 
3. 对编译器的⼀种请求，编译器有可能拒绝这种请求；
4. 缺点：存在以下编译限制：
   - **不能存在**任何形式的**循环语句** 
   - 不能存在过多的条件判断语句 
   -  函数体不能过于庞⼤ 
   -  **内联函数声明必须在调⽤语句之前**

#### 指针与引用

- **指针存放某个对象的地址，其本⾝就是变量**（命了名的对象），本⾝就有地址，所以可以有 指向指针的指针；可变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变 

- **引⽤就是变量的别名，从⼀⽽终，不可变，必须初始化** 
- **不存在指向空值的引⽤，但是存在指向空值的指针**

#### override 和 overload

- override是重写（覆盖）了⼀个⽅法
  - 场景：⼀般是⽤于⼦类在继承⽗类时，重写⽗类⽅法。
  - 规则：
    - 重写⽅法的**参数列表，返回值，所抛出的异常与被重写⽅法⼀致**
    - **被重写的⽅法不能为private**
    -  **静态⽅法不能被重写为非静态的方法**
    - **重写⽅法的访问修饰符⼀定要⼤于被重写⽅法的访问修饰符**（public>protected>default>private）
- overload是**重载**，这些⽅法的**名称相同⽽参数形式不同**
  - 场景：⼀个⽅法有不同的版本，存在于⼀个类中。
  - 规则：
    - **不能通过访问权限、返回类型、抛出的异常**等不同来进⾏重载
    - 不同的参数类型可以是**不同的参数类型，不同的参数个数，不同的参数顺序**（参数 类型必须不⼀样）
    - ⽅法的异常类型和数⽬不会对重载造成影响 ？？？


#### new 和 malloc 

1. new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时
   返回NULL。 
2. **使⽤new操作符申请内存分配时⽆须指定内存块的⼤⼩，⽽malloc则需要显式地指出所 需内存的尺⼨。**
3. opeartor new /operator delete可以被重载，⽽malloc/free并不允许重载。
4. **new/delete会调⽤对象的构造函数/析构函数以完成对象的构造/析构**。⽽malloc则不会.
5. **malloc与free是C++/C语⾔的标准库函数**,**new/delete是C++的运算符**
6. 底层中 new 的多个重载 调用的std::malloc （**两者的关系：即new封装了malloc**）
7. new操作符从⾃由存储区上为对象动态分配内存空间，⽽malloc函数从堆上动态分配内存

![image-20230215160031842](C:\Users\qq130\AppData\Roaming\Typora\typora-user-images\image-20230215160031842.png)



#### 前置++与后置++

为了区分前后置，**重载函数是以参数类型来区分**，在调⽤的时候，编译器默默给int指定为 ⼀个0

```c++
self &operator++() {
 node = (linktype)((node).next);
 return *this;
}
const self operator++(int) {
 self tmp = *this;
 ++*this;
 return tmp;
}
```

为什么后置返回对象，⽽不是引⽤

**后置为了返回旧值创建了⼀个临时对象，在函数结束的时候这个对象就会被销毁。**

为什么后置前⾯也要加const

**了防⽌使⽤i++++,连续两次的调⽤后置++重载符**，第⼀次返回的是旧值，⽽不是 原对象，你调⽤两次后置++，结果只累加了⼀次，所以我们必须⼿动禁⽌其合法化。

处理⽤户的⾃定义类型 **最好使⽤前置++，因为他不会创建临时对象，进⽽不会带来构造和析构⽽造成的格外开 销**

#### std::atomic

a++ 和 int a = b 在C++中是否是线程安全的？

从C/C++语法的级别来看，这是⼀条语句，应该是原⼦的；但从编译器得到的汇编指 令来看，其实不是原⼦的。

由于操作系 统线程调度的不确定性，那么多个线程在执⾏这两条指令时，某个线程可能会在第⼀条指令执⾏完 毕后被剥夺CPU时间⽚，切换到另⼀个线程⽽出现不确定的情况

**解决办法：** C++11新标准发布后改变了这种困境，新标准提供了对整形变量原⼦操作的相 关库，即**std::atomic，这是⼀个模板类型**

