# OOP

## 核心思想

- OOP的核心思想是数据抽象、继承和动态绑定。
  - 使用数据抽象：将类和接口与实现分离
  - 使用继承：可以定义相似的类型并对其相似关系建模
  - 使用动态绑定：可以在一定程度上忽略相似类型的区别，而以统一的方式使用他们的对象

## C++三大特性：#####

### 访问权限控制

C++通过 **public、protected、private** 三个关键字来控制成员变量和成员函数的访问权限， 它们分别表⽰公有的、受保护的、私有的，被称为**成员访问限定符**。

在**类的内部**（定义类的代码内部），⽆论成员被声明为 public、protected 还是 private，都 是**可以互相访问的，没有访问权限的限制。**

在**类的外部**（定义类的代码之外），**只能通过对象访问成员**，并且**通过对象只能访问 public 属性的成员**，**不能访问 private、protected 属性的成员**。

⽆论**共有继承、私有和保护继承**，**私有成员不能被“派⽣类”访问**，基类中的**共有和保护成员 能被“派⽣类”访问** 

对于**共有继承，只有基类中的共有成员能被“派⽣类对象”访问**，**保护和私有成员不能**被“**派 ⽣类对象**”**访问**。**对于私有和保护继承，基类中的所有成员不能被“派⽣类对象”访问**

### 继承

**让某种类型对象获得另⼀个类型对象的属性和⽅法**

它可以**使⽤现有类的所有功能，并在⽆需重新编写原来的类的情况下对这些功能进⾏扩展**

常见的继承有三种⽅式：

实现继承：指使⽤基类的属性和⽅法⽽⽆需额外编码的能⼒（）

接口继承：指仅使⽤属性和⽅法的名称、但是⼦类必须提供实现的能⼒

指⼦窗体（类）使⽤基窗体（类）的外观和实现代码的能⼒（以创建一个Windows窗体，然后我们可以继承这个窗体使得其它窗体具有与该窗体相同的版面布置、控件和行为。）



继承 ： 单一继承，多重继承？

继承链接：  public private protected  virtual non-virtual

通过public继承的 是is-a的关系 是： 是一种 的关系 

```c++
 class A:public B{ }; // A 的对象同时也是一个B的对象 ，反之不成立。
```

B是更一般化 的类 ，A是更特殊化的类。



### 封装

**数据和代码捆绑在⼀起，避免外界⼲扰和不确定性访问;**

把客观事物封装成抽象的类，并且类可以把⾃⼰的数据和⽅法只让可信的类或者对象操作， 对不可信的进⾏信息隐藏，例如：将公共的数据或⽅法使⽤public修饰，⽽不希望被访问的 数据或⽅法采⽤private修饰。

### 多态

**同⼀事物表现出不同事物的能⼒**，即**向不同对象发送同⼀消息，不同的对象在接收时会产⽣ 不同的⾏为**（**重载实现编译时多态**，**虚函数实现运行时多态**）####

多态性是允许你将⽗对象设置成为和⼀个或更多的他的⼦对象相等的技术，赋值之后，⽗对 象就可以根据当前赋值给它的⼦对象的特性以不同的⽅式运作

简称 ： **允许将⼦类类型的指针赋值给父类类型的指针**

实现多态有两种⽅式  

1.  覆盖（override）： 是指⼦类重新定义⽗类的虚函数的做法 
2.  重载（overload）： 是指允许存在多个同名函数，⽽这些函数的参数表不同（或 许参数个数不同，或许参数类型不同，或许两者都不同）

### 虚函数

当**基类希望派⽣类定义适合⾃⼰的版本**，就将这些函数声明成虚函数

虚函数依赖虚函数表⼯作，**表来保存虚函数地址**，当我们**⽤基类指针指向派生类时，虚表指针指向派⽣类的虚函数表**

这个机制可以保证派⽣类中的虚函数被调⽤到

1. **虚函数是动态绑定的**
   1. 使⽤虚函数的指针和引⽤能够正确找到实际类的对应函数，⽽不是执⾏定义类的 函数，这是虚函数的基本功能。
2. 多态（不同继承关系的类对象，调⽤同⼀函数产⽣不同⾏为）
   1. **调⽤函数的对象必须是指针或者引⽤** 
   2. **被调⽤的函数必须是虚函数**（virtual），**且完成了虚函数的重写**（派⽣类中有⼀个 跟基类的完全相同虚函数） 
3. **动态绑定绑定的是动态类型**
   1. 所**对应的函数或属性依赖于对象的动态类型**，**发⽣在运⾏期**。
4. 构造函数不能是虚函数
   1. 且在构造函数中调⽤虚函数，实际执⾏的是⽗类的对应函数，因为子类⾃⼰还没有构造好, 多态是被disable的
5. 虚函数的⼯作⽅式
   1. 依赖虚函数表⼯作的，表来保存虚函数地址，当我们⽤基类指针指向派⽣类时，虚表指针 vptr指向派⽣类的虚函数表。 这个机制可以保证派⽣类中的虚函数被调⽤到。
6. 析构函数可以是虚函数，⽽且，在⼀个复杂类结构中，这往往是必须的。
7. 将⼀个函数定义为纯虚函数。 ？？
   1. 实际上是将这个类定义为抽象类？？？，不能实例化对象；纯虚函数通常没有定义体，但也完全可 以拥有。
8. inline, static, constructor三种函数都不能带有virtual关键字。
   1. inline是在编译时展开，必须要有实体。
      1. 内联函数是指在编译期间⽤被调⽤函数体本⾝来代替函数的调⽤指令，但虚函数的多态特性 需要在运⾏时根据对象类型才知道调⽤哪个虚函数，所以没法在编译时进⾏内联函数展开。
   2. static属于class⾃⼰的类相关，必须有实体
      1. static成员没有this指针。virtual函数⼀定要通过对象来调⽤，有隐藏的this指针，实例相 关。
9. 析构函数可以是纯虚的
   1. 纯虚析构函数必须有定义体，因为析构函数的调⽤是在⼦类中隐含的。###
10. 派⽣类的override虚函数定义必须和⽗类完全⼀致。 
    1. 除了⼀个特例，如果⽗类中返回值是⼀个指针或引⽤，⼦类override时可以返回这个指针 （或引⽤）的派⽣。 ###

##### 为什么需要虚继承？#####

1. 为了解决多继承时的命名冲突和冗余数据问题
   1. C++ 提出了虚继承，使得在派⽣类中只保留⼀份间接基类的成员。其中多继承（Multiple Inheritance）是指从多个直接基类中产⽣派⽣类的能⼒，多继承的派⽣类继承了所有⽗类 的成员。
2. 虚继承的⽬的是让某个类做出声明，承诺愿意共享它的基类
   1. 使⽤多继承经常出现⼆义性
   2. 其中，这个被共享的基类就称为虚基类（Virtual Base Class），其中A 就是⼀个虚基类。在 这种机制下，**不论虚基类在继承体系中出现了多少次，在派⽣类中都只包含⼀份虚基类的成 员**。 

##### 空类

1. 为何空类的⼤⼩不是0

   1. 为了确保两个不同对象的地址不同,必须如此。那么美那么你 

   2. 类的实例化是在内存中分配⼀块地址，每个实例在内存中都有独⼀⽆⼆的⼆地址

   3. 空类也会实例化，所以编译器会给空类隐含的添加⼀个字节，这样空类实例化后就有 独⼀⽆⼆的地址了。

   4. 空类的 sizeof为1，⽽不是0。 

      1. ```c++
         class A{ virtual void f(){} };
         class B:public A{}
         类A和类B都不是空类，其sizeof都是4，因为它们都具有虚函数表的地址。
         class A{};
         class B:public virtual A{};
         A是空类，其⼤⼩为1；B不是空类，其⼤⼩为4.因为含有指向虚基类的指针。
         class Father1{}; class Father2{};
         class Child:Father1, Father2{};
         多重继承的空类的⼤⼩也是1。
         ```

      2. 何时共享虚函数地址表：如果派⽣类继承的第⼀个是基类，且该基类定义了虚函数地址表，则派⽣类就共享该表⾸址占⽤的存储单元。

      3. 除前述情形以外的其他任何情形，派⽣类在处理完所有基类或虚基类后，根据派⽣类是 否建⽴了虚函数地址表，确定是否为该表⾸址分配存储单元???

         1. ```c++
            class X{}; //sizeof(X):1
            class Y : public virtual X {}; //sizeof(Y):4
            class Z : public virtual X {}; //sizeof(Z):4
            class A : public virtual Y {}; //sizeof(A):8
            class B : public Y, public Z{}; //sizeof(B):8
            class C : public virtual Y, public virtual Z {}; //sizeof(C):12
            class D : public virtual C{}; //sizeof(D):16
            ```



#### 抽象类与接口的实现 ？？ 

**接口描述了类的⾏为和功能，而不需要完成类的特定实现**；**C++ 接口是使用抽象类来实现的接口。**

1. 类中⾄少**有⼀个函数被声明为纯虚函数**，**则这个类就是抽象类**。纯虚函数是通过在声明 中使⽤ **"= 0" 来指定的**。
2. 设计抽象类（通常称为 ABC）的⽬的，**是为了给其他类提供⼀个可以继承的适当的基 类**。**抽象类不能被⽤于实例化对象**，它**只能作为接口使⽤**。

总结：含有纯虚函数的类是抽象基类





接口类： 解除了接口与实现之间的耦合关系，effective 147

