#### 主要分为四个区域  （联系操作系统）

代码区：存放函数体的二进制代码，由操作系统进行管理

- 特点：存放cpu执行的机器指令
- 是共享和只读的				

全局区：存放全局变量和静态变量、常量

- 在程序结束后由操作系统释放

栈区：由编译器自动分配释放，存放函数的参数值，局部变量

- 不要返回局部变量的地址！（函数结束后，内存就被释放了）

堆区：有程序员创建，分配，释放。若不释放，则在程序结束时由操作系统回收

- 在c++中主要由new来在堆区开辟内存，会返回对应类型的指针
- 释放利用关键字delete
- 释放数组的时候delete要加[]:如delete [] arr；

意义：生命周期不同，更加灵活。

![image-20230216161112598](C:\Users\qq130\AppData\Roaming\Typora\typora-user-images\image-20230216161112598.png)

进程的地址空间分布 ：

从⾼地址到低地址，⼀个程序由命令⾏参数和环境变量、栈、⽂件映射区、堆、
BSS段、数据段、代码段组成。

1. 命令⾏参数和环境变量 命令⾏参数是指从命令⾏执⾏程序的时候，给程序的参数。  
2. 栈区 存储局部变量、函数参数值。栈从⾼地址向低地址增长。是⼀块连续的空间。  
3. ⽂件映射区 位于堆和栈之间。  
4. 堆区 动态申请内存⽤。堆从低地址向⾼地址增长。  
5. BSS 段 存放程序中未初始化的 全局变量和静态变量 的⼀块内存区域。  
6. 数据段 存放程序中已初始化的 全局变量和静态变量 的⼀块内存区域。  
7. 代码段 存放程序执⾏代码的⼀块内存区域。只读，**代码段的头部还会包含⼀些只读的常数变量**。



### 说⼀说C与C++的内存分配⽅式

1. 从**静态存储区域分配** 
   1. 内存在程序编译的时候就已经分配好，**这块内存在程序的整个运⾏期间都存在，如全局变 量，static变量。**
2. 在栈上创建
   1. 在执⾏函数时，**函数内局部变量的存储单元都可以在栈上创建，函数执⾏结束时这些存储单 元⾃动被释放。**栈内存分配运算内置于处理器的指令集中，效率很⾼，但是分配的内存容量 有限。
3. 从堆上分配(动态内存分配)（堆中还有文件隐射区联系操作系统的malloc）
   1. 程序在运⾏的时候⽤malloc或new申请任意多少的内存，程序员负责在何时⽤free或delete 释放内存。动态内存的⽣存期⾃⼰决定，使⽤⾮常灵活

#### new、delete、malloc、free关系  @###￥#￥#

如果是带有⾃定义析构函数的类类型，⽤ new [] 来创建类对象数组，⽽⽤ delete来释放会 发⽣什么？

```c++
class A {};
A* pAa = new A[3];
delete pAa;
```

那么 delete pAa; 做了两件事：  1. 调⽤⼀次 pAa 指向的对象的析构函数 2. 调⽤ operator delete(pAa);释放内存

这⾥只对数组的第⼀个类对象调⽤了析构函数，后⾯的两个对象均没调⽤析构函数， 如果类对象中申请了⼤量的内存需要在析构函数中释放，⽽你却在销毁数组对象时少调⽤了 析构函数，这会造成内存泄漏。 上⾯的问题你如果说没关系的话，那么第⼆点就是致命的了！直接释放pAa指向的内存空 间，这个总是会造成严重的 段错误，程序必然会奔溃！因为分配的空间的起始地址是 pAa 指向的地⽅减去 4 个字节的地⽅。你应该传⼊参数设为那个地址！

## 内存泄露

#### 什么是内存泄露?

内存泄漏(memory leak)是指**由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况**。内存泄漏并⾮指内存在物理上的消失，⽽是应⽤程序分配某段内存后，由于设计错误， 失去了对该段内存的控制，因⽽**造成了内存的浪费**。

使⽤Valgrind, mtrace进⾏内存泄漏检查。

#### 内存泄漏的分类

1. 堆内存泄漏 （Heap leak）
   1. 对内存指的是**程序运⾏中根据需要分配通过malloc,realloc new等从堆中分配的⼀块内存**， 再是**完成后必须通过调⽤对应的 free或者 delete 删掉**。如果程序的设计的错误导致这部分 内存没有被释放，那么此后这块内存将不会被使⽤，就会产⽣ Heap Leak. 
2. 系统资源泄露（Resource Leak） 
   1. 主要指程序使⽤系统分配的资源⽐如 **Bitmap,handle ,SOCKET 等没有使⽤相应的函数释放 掉，导致系统资源的浪费**，严重可导致系统效能降低，系统运⾏不稳定。 
3. 没有将基类的析构函数定义为虚函数
   1. 当基类指针指向⼦类对象时，如果**基类的析构函数不是 virtual，那么⼦类的析构函数将不 会被调⽤**，⼦类的资源没有正确是释放，因此造成内存泄露。



#### 什么操作会导致内存泄露?

**指针指向改变，未释放动态分配内存**。 

#### 如何防⽌内存泄露?

1. 将**内存的分配封装在类中**，**构造函数分配内存**，**析构函数释放内存**；
2. **使⽤智能指针**

#### 智能指针有了解哪些？

智**能指针是为了解决动态分配内存导致内存泄露和多次释放同⼀内存所提出的**，C11标准中 **放在< memory>头⽂件**。包括:**共享指针，独占指针，弱指针** 

#### 构造函数，析构函数要设为虚函数吗，为什么？

析构函数 

析构函数需要。**当派⽣类对象中有内存需要回收时，如果析构函数不是虚函数，不会触发动 态绑定，只会调⽤基类析构函数，导致派⽣类资源⽆法释放，造成内存泄漏。**

构造函数 

构造函数不需要，没有意义。虚函数调⽤是在部分信息下完成⼯作的机制，允许我们只知道 接⼜⽽不知道对象的确切类型。 **要创建⼀个对象，你需要知道对象的完整信息。 特别是， 你需要知道你想要创建的确切类型。 因此，构造函数不应该被定义为虚函数。**
