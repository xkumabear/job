2. 吧打开一个网页的流程

3. 如何实现http

4. HTTP协议有状态吗？

   1. 无状态、明文传输
   2. 解法方案： **Cookie** 

5. HTTPS

   1. HTTP 的安全问题（明文传输），可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致
   2. HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
   3. 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
   4. 

6. HTTP怎么维护状态？

7. HTTP是什么？
   1. 超文本传输协议
   2. **双向协议**。
   3. **HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。**

8. HTTP状态码
   1. 2xx成功；3xx重定向；4xx客户端错误；5xx服务端错误

9. HTTP 缓存有哪些实现方式？

   1. **强制缓存和协商缓存**

10. tcp accept什么时候返回

11. select和epoll的实现，为什么效率不一样

12. 如何将客户端连接派发到线程池中

13. TCP握手挥手状态

14. TCP三次握手，四次挥手原因，状态转换
    1. 三次握手
       - 一开始，客户端和服务端都处于 `CLOSED` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态。
       - 然后客户端主动发起连接 `SYN`，之后处于 `SYN-SENT` 状态。
       - 服务端收到发起的连接，返回 `SYN`，并且 `ACK` 客户端的 `SYN`，之后处于 `SYN-RCVD` 状态。
       - 客户端收到服务端发送的 `SYN` 和 `ACK` 之后，发送对 `SYN` 确认的 `ACK`，之后处于 `ESTABLISHED` 状态，因为它一发一收成功了。
       - 服务端收到 `ACK` 的 `ACK` 之后，处于 `ESTABLISHED` 状态，因为它也一发一收了。
    2. 三次握手的目的是确保双方都有发送和接收的能力。根本目的是解决历史连接问题，浪费了服务端资源。
    3. 状态位：`SYN` 是发起一个连接，`ACK` 是回复，`RST` 是重新连接，`FIN` 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。

15. get和post最大的区别
    1. 

16. 有几种进入TIME_WAIT的方式：
    - 正常情况
    - 双方同时主动关闭，进入FIN_WAIT1后同时接收到ACK直接进入TIME_WAIT
    - 双方同时主动关闭，进入FIN_WAIT1后先接到FIN，进入CLOSING后接到ACK进入TIME_WAIT

17. TCP三次握手状态变化

18. TCP滑动窗口

19. TCP拥塞控制

20. 第三次握手可以携带数据吗

    1. **第三次握手是可以携带数据的，前两次握手是不可以携带数据的**

21. TCP三次握手为什么不是四次呢

    1. 三次握手才可以阻止重复历史连接的初始化（主要原因）
    2. 三次握手才可以同步双方的初始序列号
    3. 三次握手才可以避免资源浪费
    4. **两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费**
    5. 四次握手其实也能够可靠的同步双方的初始化序号，但由于**第二步和第三步可以优化成一步**，所以就成了「三次握手」。

22. TCP四次挥手可以三次吗

    四次挥手：

    1. 客户端打算关闭连接，此时会发送一个 TCP 首部 `FIN` 标志位被置为 `1` 的报文，也即 `FIN` 报文，之后客户端进入 `FIN_WAIT_1` 状态。
    2. 服务端收到该报文后，就向客户端发送 `ACK` 应答报文，接着服务端进入 `CLOSE_WAIT` 状态。
    3. 客户端收到服务端的 `ACK` 应答报文后，之后进入 `FIN_WAIT_2` 状态。
    4. 等待服务端处理完数据后，也向客户端发送 `FIN` 报文，之后服务端进入 `LAST_ACK` 状态。
    5. 客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文，之后进入 `TIME_WAIT` 状态
    6. 服务端收到了 `ACK` 应答报文后，就进入了 `CLOSE` 状态，至此服务端已经完成连接的关闭。
    7. 客户端在经过 `2MSL` 一段时间后，自动进入 `CLOSE` 状态，至此客户端也完成连接的关闭。

    需要注意是：**主动关闭连接的，才有 TIME_WAIT 状态。**

    为什么不是三次：

    - 关闭连接时，客户端向服务端发送 `FIN` 时，仅仅表示客户端不再发送数据了但是还能接收数据。
    - 服务端收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接。

23. tcp和udp的区别

    1. TCP 是**面向连接的、可靠的、基于字节流**的传输层通信协议。
    2. UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。
    3. 连接；服务对象；可靠性；*拥塞控制、流量控制*；*首部开销*；*传输方式*；*分片不同*；

24. tcp的可靠性是怎么保证的

    1. TCP为了保证可靠性，采用了三次握手，四次挥手等机制，除此之外还有滑动窗口和拥堵控制算法。最最关键的是还保留了超时重传的机制。对于每份报文也存在校验，保证每份报文的可靠性。

       用序列号保证按序到达：在建立连接时初始化一个随机数，通过SYN包传给接收端主机，每发送一次数据，就累加一次该数据字节数的大小。用来解决网络包乱序的问题。

25. ​     视频会议用的是tcp还是udp, 为什么

26. udp, qq视频那种的画质自动调节是怎么实现的

27. udp怎么设置端口复用

28. 端口复用和地址复用的区别

29. TCP和UDP监听同一个端口的惊群现象

30. tcp半连接队列和全连接队列

    1. **半连接队列（SYN队列）**，服务端收到**第一次握手**后，会将`sock`加入到这个队列中，队列内的`sock`都处于`SYN_RECV` 状态。
    2. **全连接队列（ACCEPT队列）**，在服务端收到**第三次握手**后，会将半连接队列的`sock`取出，放到全连接队列中。队列里的`sock`都处于 `ESTABLISHED`状态。这里面的连接，就**等着服务端执行accept()后被取出了。**

    建立连接的过程中根本不需要`accept()`参与， **执行accept()只是为了从全连接队列里取出一条连接。**

31. syn flood攻击

    1. 假设攻击者短时间伪造不同 IP 地址的 `SYN` 报文，服务端每接收到一个 `SYN` 报文，就进入`SYN_RCVD` 状态，但服务端发送出去的 `ACK + SYN` 报文，无法得到未知 IP 主机的 `ACK` 应答，久而久之就会**占满服务端的半连接队列**，使得服务端不能为正常用户服务。

32. 怎么解决syn flood攻击？

    1. 调大 netdev_max_backlog；
    2. 增大 TCP 半连接队列；
    3. 开启 tcp_syncookies；
    4. 减少 SYN+ACK 重传次数

33. TCP四次挥手的close_wait状态是在什么时候？出现大量close_wait有什么影响，怎么排查？

    - 客户端打算关闭连接，此时会发送一个TCP报文，FIN标志被置为1，之后客户端进入FIN_wait_1状态
      服务端收到该报文后，向客户端发送ACK报文，接着服务器进入CLOSED_WAIT状态
      客户端收到服务端的ACK报文之后，进入FIN_wait_2状态
      等待客户端处理完数据后，也向客户端发送FIN报文，之后服务端进入LAST_ACK状态
      客户端收到服务器的FIN报文后，回一个ACK应答报文，之后进入TIME_WAIT状态
      服务器接收到ACK应答报文后，就进入CLOSED状态，至此服务端已经完成连接的关闭
      客户端在经过2MSL等待时间之后，自动进入CLOSED状态，至此客户端也完成连接的关闭
    - 

34. 出现大量CLOSE_WAIT状态正常吗？

    1. CLOSE_WAIT 状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。

       所以，**当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接**。

35. 出现大量TIME_WAIT状态？

    1. 如果是与同一个服务器建立的链接 如果客户端 TIME_WAIT 状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。
    2. **因为只要客户端连接的服务器不同，端口资源可以重复使用的**。所以，如果客户端都是与不同的服务器建立连接，即使客户端端口资源只有几万个， 客户端发起百万级连接也是没问题的
    3. 

36. TIME_WAIT需要等待多长时间？

    1. TIME_WAIT 这个状态里停留一段时间，这个时间大约为 2MSL。
    2. 防止历史连接中的数据，被后面相同四元组的连接错误的接收；
    3. 保证「被动关闭连接」的一方，能被正确的关闭；

37. 为什么需要等待2MSL？//清空信道

    1. `MSL` 是 Maximum Segment Lifetime，**报文最大生存时间**

38. tcp返回EGIAN是什么问题？

39. close一定会四次挥手吗？

40. 如何强制close？

41. tcp如何在应用感知对端close？

42. TCP通讯，服务端的程序挂掉了，客户端会怎么样？

    1. 如果有数据传输：
       在客户端拔掉网线后，服务端向客户端发送的数据报文会得不到任何的响应，在等待一定时长后，服务端就会触发超时重传机制，重传未得到响应的数据报文。
    2. 如果在服务端重传报文的过程中，客户端刚好把网线插回去了，由于拔掉网线并不会改变客户端的 TCP 连接状态，并且还是处于 ESTABLISHED 状态，所以这时客户端是可以正常接收服务端发来的数据报文的，然后客户端就会回 ACK 响应报文。此时，客户端和服务端的 TCP 连接依然存在的，就感觉什么事情都没有发生。
    3. 但是，如果如果在服务端重传报文的过程中，客户端一直没有将网线插回去，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，于是服务端的 TCP 连接就会断开。而等客户端插回网线后，如果客户端向服务端发送了数据，由于服务端已经没有与客户端相同四元祖的 TCP 连接了，因此服务端内核就会回复 RST 报文，客户端收到后就会释放该 TCP 连接。此时，客户端和服务端的 TCP 连接都已经断开了。
    4. 如果拔掉网线后，没有数据传输。针对拔掉网线后，没有数据传输的场景，还得看是否开启了 TCP keepalive 机制 （TCP 保活机制）。
    5. 如果没有开启 TCP keepalive 机制，在客户端拔掉网线后，并且双方都没有进行数据传输，那么客户端和服务端的 TCP 连接将会一直保持存在。
    6. 而如果开启了 TCP keepalive 机制，在客户端拔掉网线后，即使双方都没有进行数据传输，在持续一段时间后，TCP 就会发送探测报文：如果对端是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。