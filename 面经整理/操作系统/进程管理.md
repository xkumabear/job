### 什么是**惊群效应**？

多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态），如果等待的这个事件发生，那么他就会唤醒等待的所有进程（或者线程），

但是最终却只可能有一个进程（线程）获得这个时间的“控制权”，对该事件进行处理，而其他进程（线程）获取“控制权”失败，只能重新进入休眠状态，这种现象和性能浪费就叫做惊群。

危害：系统对用户进程/线程频繁地做无效的调度，加大了系统开销。

解决办法：

·1、 ***当有新的连接进入到accept队列的时候，内核唤醒且仅唤醒一个进程来处理\***

2、 加锁：无论有多少个进程，同一时刻只能有一个worker进程在自己的epoll中加入监听的句柄

僵尸进程： 父进程退出，没有善后子进程；通过计数；

### fork写时拷贝作用？

当fork一个进程时，若将父进程的所有用户空间[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)复制到子进程中。当如果父进程较大，则复制可能需要很长时间。且经常造成大量浪费，很多内存页没有被访问到，子进程就销毁了；

解决办法：写诗拷贝：复制进程的相关资源时，不复制页，先映射到同一物理内存页，赋予共同的只读权限，当存在进程想要修改某个资源页时，再进行真正的复制。

##### vfork什么作用？

**vfork** 调用之后，子进程先被调度。调用 **vfork** 创建子进程并不复制父进程的，子进程可以通过 exec 函数族，直接启动另一个进程替换自身。



1. 线程同步机制
2. 线程有什么资源是私有的？
3. 条件变量为什么需要加锁？
5. 进程和线程，通信方式，最快的进程通信方式，第二快呢？
6. Linux write系统调用的整个流程
7. select和epoll区别
8. 协程原理，如何实现协程
8. 僵尸进程和孤儿进程： 
   1. 僵尸进程死了，父进程没有善后 解决办法 wait 使用信号量阻塞父进程并进行善后。
   2. 孤儿进程  子进程还在运行，父进程死了 ， init 进行善后但是占用系统资源。
9. 多线程和多进程的优缺点和注意事项
10. 为什么使用线程池、对象池
10. 为什么系统调用比较消耗CPU
12. malloc申请100B和申请100MB的区别；释放100MB呢
    1. *malloc申请的*空间大于128KB的话,调用的是mmap函数

13. 内存管理器tcmalloc

