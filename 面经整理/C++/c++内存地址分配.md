1. cpp内存地址空间分配  

   1. 内存地址结构 2、栈堆如何分配 3 二者的区别

   2. **从低地址到高地址，一个程序由代码段，数据段，BSS端，堆，共享区，栈**等组成。

   3. 代码段：存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量
      数据段：存放程序中已经初始化的全局变量和静态变量的一块内存区域。
      BSS段：存放未初始化的或者初始化为0的全局变量和静态变量的一块内存区域
      可执行程序在执行时又会多出两个区域：堆区和栈区
       堆区：动态申请内存用，堆从低地址向高地址增长

       栈区：存储局部变量，函数参数值，由高地址向低地址增长。是一块连续的空间

       最后还有一个共享区，位于堆和栈之间

2. 2 GB 内存的操作系统中，可以分配4 GB 的数组吗？

   1. 如果2GB内存指的是物理内存，那么就要区分是32位系统还是64位操作系统

      32位操作系统最多申请出3g虚拟内存，所以是不可以的

      64位操作系统最多申请出128T虚拟内存，则可以

      如果2G内存指的是虚拟内存，直接不可以

3. malloc从哪里分配内存 ？malloc内存管理

   1. 分配小块内存时 调用 brk 系统调用从堆分配内存，（分配大文件会产生越来越多的内存碎片。）

   2. 分配内存大，通过 mmap() 系统调用在文件映射区域分配内存；

   2. 两种分配的都是虚拟内存，并没有分配实际物理内存

   3.  free 内存后堆内存还存在，是针对 malloc 通过 brk() 方式申请的内存的情况。-->free如何知道需要释放多多少空间？堆头！

      如果 malloc 通过 mmap 方式申请的内存，free 释放内存后就会归归还给操作系统。

4. new 有什么办法判断判断分配失败？ //1：异常，2：返回值

5. new和malloc的区别

   1. malloc与free是C语言的标准库函数， new/delete是C++的运算符， 他们都可以用来申请和释放内存， malloc和free不在编译器控制权限之内， 无法调用构造函数和析构函数；而new/delete是由C++编译器控制的，可以在分配内存之外调用构造函数和析构函数。
   
6. memcpy：

   1. ![image-20230306202438557](C:\Users\qq130\AppData\Roaming\Typora\typora-user-images\image-20230306202438557.png)
   1. 需要考虑重叠问题，上面并未考虑到。
   
6. 内存泄漏的排查手段；

   1. 打印new delete 判断数量
   1. Visual Leak Detecter VLD
   
8. 内存泄漏有哪些场景？

   1. 最常见的，定义的对象，从堆申请的空间没有释放，没有调用free delete
   2. 类中 析构函数没有析构所属成员的资源对象
   3. 没有正确的清楚嵌套的对象指针
   4. 释放对象数组是没有使用delete[]
   5. 没有正确的清理，对象指针的数组
   6. 没有将基类的析构函数定义为虚函数
   7. 缺少拷贝的构造函数
   8. 构造函数中抛出了异常




引：

1. 内存碎片：
2. 内存不足操作系统会怎么做？



1. 怎么实现一个对象只允许在堆上定义
   1. 私有化析构；
   2. 定义工厂方法；
2. 怎么实现一个对象只允许在栈上定义
   1. 重新定义类的 new 运算符；