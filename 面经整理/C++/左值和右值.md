1. 右值引用：

   1. *右值引用是为了尽量减少临时对象的不需要的复制带来的性能问题*
   
2. 引用折叠：

   1. 存在T&&这种万能引用类型，当它作为参数时，有可能被一个左值引用或右值引用的参数初始化，这是经过类型推导的T&&类型，相比右值引用(&&)会发生类型的变化，这种变化就称为引用折叠。

2. 假如 a 是 T 的左值引用，T 是 int&& 类型的，那么 a 实际上是什么 int&

3. move

   1. move对于拥有如内存、文件句柄等资源的成员的对象有效，如果是一些基本类型，如int和char[10]数组等，如果使用move，仍会发生拷贝（因为没有对应的移动构造函数），所以说move对含有资源的对象说更有意义。

4. 什么是完美转发？完美转发

   1. 无论调用 function() 函数模板时传递给参数 t 的是左值还是右值，对于函数内部的参数 t 来说，它有自己的名称，也可以获取它的存储地址，因此它永远都是左值，也就是说，传递给 otherdef() 函数的参数 t 永远都是左值。

   2. 所以需要完美转发，完美转发 = std::forward + 万能引用 + 引用折叠

   3.  

      ```c++
      forward 被用在其他模板中所以 其T隐含由 
      <typename T>
      T&& forward( typename remove_reference<T>::type& param ){
          return static_cast<T&&> param;
      }
      ```

      

5. 万能引用：

   1. 只有涉及类型推导的引用，才会是万能引用。就是它的形式必须是“T&&”，基于这个原因，即使是一个const饰词，一个看上去是万能引用的场合可能也只是个右值引用。

6. 类型推导：

   1. 以下是 auto 关键字对 cv 限定符的推导规则：
      如果表达式的类型不是指针或者引用，auto 会把 cv 限定符直接抛弃，推导成 non-const 或者 non-volatile 类型。
      如果表达式的类型是指针或者引用，auto 将保留 cv 限定符。

      对引用的处理
      当表达式的类型为引用时，auto 和 decltype 的推导规则也不一样；decltype 会保留引用类型，而 auto 会抛弃引用类型
   
8. std::move()说一下

   1. std::move(); 是c++里面用来实现移动语义的重要方式，
   2. 移动是指**将对象的状态或者所有权从一个对象转移到另一个对象**，
   3. 目的是：避免内存拷贝，降低性能开销
   4. 这个函数只做了一件事情就是，将传入的对象，类型强制转换为右值引用类型；
   5. 其实际意义是：转移资源所有权；

9. 左值与右值

   1. 当一个对象左值的时候，使用的是它的地址；
   1. 当一个对象被用作右值的时候，使用的是它的值
   1. 左值可以取地址，有具体的名字
   1. 右值不可以取地址，没有具体的名字

10. 左值引用和右值引用 ：对左值和右值起别名

