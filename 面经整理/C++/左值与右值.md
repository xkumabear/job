## 类型推导规则

- 情况一  paramType 是引用或者指针的情况下
  - 忽略表达式的引用，进行推导

- 情况二 paramType 是万能引用的情况
  - 一定是引用
  - 左值的情况下推导为左值引用
  - 右值忽略引用进行推导T，T&&最终推导为右值引用

- 情况三 paramType  是值的情况
  - 因为传入函数的为参数的拷贝,不可假定其也有CV属性，所以忽略顶层CV
  - 若表达式具有引用型别，忽略其引用型别。  

边缘情况：

- 数组实参与函数实参

  - 在模板推导过程中，数组和函数型别的实参会退化成对应的指针 ，  除非当其被用来初始化引用。

  - 例子：利用这种特性，我们可以使用模板，来推导数组的元素个数 

  - 

    ```c++
    template<typename T , std::size N>
    constexpr std::size_t arraySize( T(&)N ){
        return N;
    }
    //声明为常量表达式可以让其返回值在编译期就可用。
    ```


### AUTO 型别推导

- auto 型别推导就是模板T型别，隐式初始化推导的过程
- auto 型别推导运用在数组上 ，数组也是退化为指针。
- auto型别推断的特例：当列表初始化 { } 时（统一初始化）此时将发生两次型别推导：
  - 第一次auto 将初始化表达式的型别推导为 std::initializer_list<T> ，但是这是一个模板所以
  - 第二次类型推导该模板的T值，所以此处初始化列表中的类型必须统一否则将会导致类型推导失败。 

**auto 与 模板型别推导的唯一区别就在于：**

- **auto 会假定用大括号括起来的表达式为std::initializer_list<T>;**
- **模板类型推导不会假定！会报错，无法推导T的型别；**
- 解决办法 将模板中的参数设为 std::initializer_list<T>；

拓展：在c++14中使用auto作为返回值类型推导、和lambda表达式中的形参推导，都是使用模板型别推导的规则。所以也无法处理{}问题

### decltype 型别推导：

用在名字上，得到该名字的声明型别；

将decltype 应用在一个名字之上，就会得出该名字的声明型别。虽然名字是左值，但是在仅有一个名字的条件下，就是这样推断。

但是一旦是除只有名字外的左值表达式时，此时总是推断出左值引用

```c++
decltype(x);
decltype((x));
在c++14中，该问题会滚成更大的雪球

decltype(auto) func(){
    int x = 0;
    return x;
    return (x); //返回了局部变量的引用！ 是危险的
}
```

### 引用折叠

 如果任一引用为左值引用，则结果为左值引用。否则（即两个都是右值引用），结果为右值引用。

​     引用折叠存在四种情形，根据上面的规则我们可以知道：

​       1）左值-左值 `T& &   <=>  int &`

​       2）左值-右值 `T& &&   <=>  int &`

​       3）右值-左值 `T&& &   <=>  int &`

​       4）右值-右值 `T&& &&  <=>  int &&`
