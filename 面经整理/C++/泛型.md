1. 你 cpp模板为什么必须定义在头文件

   1. **这是由C++编译器的性质决定的。C++采用了分离式编译的方法**，**.h头文件仅仅是在预处理阶段进行展开的**，真正进行的是对.cpp文件的编译。编译器在编译时，看到模板并不会进行任何操作，而是在模板实际使用时（实例化），才会进行代码生成。
   2. 如果模板声明放在.h头文件中，模板实现放在.cpp文件中，编译时可以看到模板的声明但找不到定义，因此会成为外部符号，而在链接时，必然无法找到模板的实现（该外部符号的对应符号），导致链接失败。而如果模板定义在.h头文件中，则可以在编译时就找到模板的定义，进行代码生成。
      

2. cpp 模板全特化和偏特化的区别

   1. 偏特化和全特化的不同之处在于：**全特化将所有的模板参数都固定下来**，因而对类模板、函数模板特化的结果不再是模板，因为**它不具有模板的可扩展性了，而是具有普通的类、普通的函数的性质**。但是**偏特化仍然保留了一部分的未定参数，仍然具有一定程度上的可扩展性**，这使得**偏特化后的结果仍然是模板**。

   2. 偏特化包含两种：

      ​       1.模板中的模板参数没有被全部确定，需要编译器在编译时进行确定。

      ​       2.在类型上加上const、&、*（ cosnt int、int&、int*、等等）并没有产生新的类型。只是类型被修饰了。
   
3. 普通模板函数定义在哪里，为什么；

   1. 对于普通文件来说，声明放在头文件，而普通的函数模板定义在头文件中。

4. 普通模板函数定义在头文件里为什么链接器不报符号重定义；

   1. 

5. 如果源文件a和b中都使用了模板函数，为什么不报重定义的错误

   1. 编译器对这种情况进行了特殊处理，当模板在一个编译单元里被实例化时，它并不知道在其他的编译单元是否也被实例化。因此当一个函数模板在多个编译单元同时实例化时，会生成重复的代码。编译器把这些段命名 link-once 在连接时，就会对重复的代码进行整合，只链接唯一的代码段，丢弃重复段。（该做法在处理外部内联函数和虚函数表时也是类似如此）
   2. 这个连接是随机连接的一个代码段副本，所以如果 不同的编译单元使用不同的编译器，或特殊优化选项，那编译出的代码不同。此时会抛出警告，并随机连接。
   3. 使用特化后的函数，会导致多重定义；
   4. 解决办法： 内联特化，namespace 定义成局部作用域，提到需要特化的文件；

6. 报重定义错误的场景有哪些？有什么解决办法？

   1. 一般常见的重定义错误，根本原因是因为在不同的文件中生成了同样的全局强符号链接（global symbol）；
   2. 常见的符号链接有3种，全局符号链接，局部符号链接，弱符号链接
   3. 未初始化的全局变量名是弱符号，初始化后的全局变量名是强符号；
   4. 解决办法： 
      1. 只在一个翻译单元中给出函数的定义
      2. 将全局符号链接，变为局部符号链接 加namespace 和 static
      3. 变成两个弱符号链接： inline inline 的另一个作用就是声明函数为弱符号链接。

   5. 除了 inline 会生成 Weak Symbol, 模板生成的内容也是 Weak Symbol. 所以模板可以放在[头文件](https://www.zhihu.com/search?q=头文件&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1942405670})中, 而不用有担心重定义的错误.

7. 



**C/C++源文件是按编译单元（translation unit）分开、独立编译的。**

**编译器为模板生成实例的必要条件是：1. 知道模板的具体定义/实现；2. 知道模板参数对应的实际类型。**

编译器编译某一个 .cpp 文件时并不知道另一个 .cpp 文件的存在，也不会去查找 且当一个模板不被用到的时侯，它就不该被实例化出来。

所以在链接阶段无法连接有效的模板函数。



**SFINAE表示替换失败不是错误**( Substitution Failure Is Not An Error)。简单地说，替换就是尝试用提供的类型或值替换模板参数的机制。在某些情况下，如果替换导致无效代码，编译器不应该抛出大量错误，而应该继续尝试其他可用的重载。SFINAE概念只是为“健全”的编译器保证这种“健全”的行为。

替换就是尝试用提供的类型或值替换模板参数的机制。在某些情况下，如果替换导致无效代码，编译器不应该抛出大量错误，而应该继续尝试其他可用的重载。SFINAE概念只是为“健全”的编译器保证这种“健全”的行为。