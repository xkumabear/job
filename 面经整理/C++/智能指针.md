1. cpp智能指针内容及应用；三种智能指针？各自有什么用处；
   1. 智能指针是一个类，这个类的**构造函数中传入一个普通指针**，并**析构函数中释放传入的指针**。**智能指针的类都是栈上的对象**，**所以当函数（或程序）结束时会自动被释放。**
   1. std::auto_ptr，有很多问题。 不支持复制（拷贝构造函数）和赋值（operator =），但复制或赋值的时候不会提示出错。因为不能被复制，所以不能被放入容器中。
   1. unique_ptr， 也不支持拷贝和赋值，但比auto_ptr好，**直接赋值会编译出错。实在想赋值的话，需要使用：std::move。**
   1. shared_ptr，基于引用计数的智能指针。可随意赋值，直到内存的引用计数为0的时候这个内存会被释放。
   1. weak_ptr，弱引用。 引用计数有一个问题就是互相引用形成环，这样两个指针指向的内存都无法释放。需要手动打破循环引用或使用weak_ptr。**只引用，不计数。`weak_ptr`不具备普通指针的特性，无法直接使用资源**，这点符合`weak_ptr`的定义
1. 注意事项，可否在STL容器中使用？ 
   1. 不能在容器中使用'auto_ptr ； shared_ptr的引用循环；weak_ptr使用之前需要检查weak_ptr是否为空指针。
1. 野指针和悬空指针的区别？怎么预防；**
   1. 野指针：未初始化的指针
   1. 悬空指针：指针指向的对象被释放，但仍然**指向已经被回收的内存地址，这种情况下的指针叫做悬空指针**
   1. 相同点：都是指向无效的内存区域
   1. 如何避免野指针：在定义时就进行初始化 nullptr
   1. 如何避免空悬指针：delete 指针指向的内存空间被释放后 将指针赋空值。
1. c++四种cast转换
   1. const_cast：常量转换，用于将const变量转为非const
   1. static_cast：用于各种隐式转换，比如非const转const，void*转指针等，static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知。
   1. dynamic_cast ：用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。
      1. 向上转换：指的是子类向基类的转换
      1. 向下转换：指的是基类向子类的转换
      1. 它通过判断在执行到该语句的时候变量的运行类型和要转换的类型是否相同来判断是否能够进行向下转换
   1. reinterpret_cast：几乎什么都可以转，比如将int转指针，可能会出现问题，尽量少用。
1. weak_ptr的lock()函数怎么知道share_ptr是否存在
   1. lock。此函数检查weak_ptr指向的对象是否存在。如果存在，lock返回一个指向共享对象的shared_ptr。与任何其他的shared_ptr类似，只要此shared_ptr存在，他所指向的对象一定存在。
   1. 通过用来保存的share控制块，先判断是否被释放，是返回空指针，否则增加引用并生成新的共享指针。？
1. 全用share_ptr就能解决内存泄漏了么
   1. 循环引用问题，还要配合weak_ptr使用
1. shared_ptr，引用计数何时增加和减少： 
   1. 生成新的共享指针对象增加，析构共享对象时减少，
1. 如何用普通指针初始化 shared_ptr： reset
1. 用普通指针初始化 shared_ptr 这种用法有什么坏处： 
   1. 可能导致空悬指针，内存分配不连续不高效。
1. 指针、地址和引用的区别
   - 指针是所指内存的地址；
   - 引用是别名、引用必须初始化，并且初始化后不能重新引用其它变量；
   - 指针变量 带有型别，指向了地址；
   - 在编译阶段 引用是对指针的封装，使用指针实现的。