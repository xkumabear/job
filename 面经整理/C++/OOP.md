1. 多态，主要是用来做什么？
   1. 同⼀事物表现出不同事物的能⼒，即向不同对象发送同⼀消息，不同的对象在接收时会产⽣ 不同的⾏为（重载实现编译时多态，虚函数实现运⾏时多态）
   
2. cpp多态怎么实现，虚函数指针虚函数表内存空间

3. 虚表在类中是怎么存放的？
   1. 存放在只读数据段
   2. 对象中有虚函数表指针指向虚表
   3. 虚表中存有虚函数指针，指向代码段中的虚函数方法
   3. 这个虚指针一般位于对象的起始地址。通过虚指针和偏移量计算出虚函数的真实地址实现调用。
   
4. 虚函数表指针的偏移量是如何计算出来的?如何真 正找到我想到访问的函数

   1. 虚函数按照声明顺序在虚函数表中排列，偏移量就是该虚函数的声明顺序。
   2. 多继承体系下子类虚函数放在继承的第一个父类的虚函数表中，但若覆盖了某个父类的虚函数，则在虚函数表中覆盖相应的地址。

5. 运行时这个类型是怎么识别的？类型信息存在哪里?

   RTTI机制  run-time type infomation/identify

   运行时的类型识别 RTTI机制是什么？

   RTTI也是通过vfptr和vftable来实现的，vftable里面存在RTTI指针 => RTTI信息的字符串的地址。

6. 虚函数是什么？虚函数可以内联吗
   1. **inline是在编译器将函数类容替换到函数调用处，是静态编译的。**而**虚函数是动态调用的**，在编译器并不知道需要调用的是父 类还是子类的虚函数，所以**不能够inline声明展开，所以编译器会忽略**

7. static函数可以是虚函数吗？
   1. **静态成员函数没有this指针。**虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它。对于静态成员函数，它没有this指针，所以无法访问vptr. 这就是为何static函数不能为virtual.

8. 构造函数可以是虚函数吗？
   1. 不可以
   2. 从虚指针方面来讲：虚函数是通过对象的虚函数表查找虚函数指针来调用的，当初始化对象时，此时的虚函数表指针还未初始化，所以从逻辑上无法调用。是矛盾的
   3. 从多态的角度来说，父类指针根据动态绑定的子类对象，动态选择调用方法，而用于初始化的构造函数，不可能由父类指针进行调用。而是主动调用生成对象的。

9. 析构函数可以是虚函数吗？
   1. 可以

10. 析构函数为什么要用虚函数

   11. 当基类指针p指向子类，进行delete时，若析构不是虚函数则只运行了基类A的析构；如果子类B中有资源需要释放那么这种情况会造成资源泄漏。

   2. 如果把基类的析构函数定义为虚函数就能正确释放子类中的资源。

11. 如果基类实现了虚函数但没有多态，可以内联吗？
    1. 可以，因为内联是对编译器的一种建议，编译器会智能判断能否内联，此时可以判断出来。

12. 在构造和析构函数中调用虚函数会怎样：
    1. 从语法上讲，调用完全没有问题。
    2. 但是从效果上看，往往不能达到需要的目的。不会呈现出多态的。
    3. 子类对象在构造时先构造基类部分，再构造子类部分；在析构时先析构子类部分再析构基类部分。
    4. 子类对象在构造基类部分时，此时子类对象部分处于未被初始化的状态。
    5. 当子类对象析构基类部分时，此时子类对象部分处于已析构状态。
    6. 如果在基类部分进行构造或者析构时调用子类的成员很可能会造成程序崩溃。

13. C++菱形继承的问题？虚继承的原理？
    1. 菱形虚拟继承因为子类对象当中会有两份父类的成员，因此会导致数据冗余和二义性的问题。
    2. 虚继承对于相同的虚基类在对象当中只会存储一份，若要访问虚基类的成员需要通过虚基表获取到偏移量，进而找到对应的虚基类成员，从而解决了数据冗余和二义性的问题。

14. 继承是否破坏了封装？

    1. 分类讨论，
    2. **该短语所指的是被继承的虚拟接口现在未被封装的事实**。 实际上，继承意味着隐藏的某些事物现在暴露出来。 像protected成员和virtual private成员这样的东西都可以通过派生类开放。  非virtual private成员仍然是隐藏的。 

15. 重载和重写有什么区别
    1. 重载：函数和运算符重载，是实现静态多态的方法。不同的函数使用相同的函数名其参数类型或个数不同，函数重载跟返回值无关。重写：实现多态，派生类中函数对基类函数进行重写，起就是虚函数。
    1. 在C++语言中，名字查找发生在类型检查前

16. delete父类指针发生了什么
    1. 

17. 实现string拷贝构造函数

18. 空类包括什么成员
    1. 编译器会给空类隐含的添加⼀个字节，使得空类实例化后就有 独⼀⽆⼆的地址了。 

19. 一个类的大小由什么决定（成员变量的个数，是否继承，是否有虚函数等，有虚函数的话，那么类就会多一个虚表指针，类的大小就会多4字节）
    1. 变量+虚函数表指针+多继承的多虚函数表指针

20. 一个子类继承空基类，对子类的大小会有影响吗 (空白基优化)
    1. 若同时继承了两个空类则有影响，增加了两个字节；
    2. 若只继承了一个空类则不占空间；
    3. NoEmpty的基类Empty和EmptyToo不能分配在同一地址空间，C++内存布局不允许相同类型的子对象偏移量相同。
    4. 只要类型不同可以偏移量重叠
    5. 为什么类型大小不能为0因为类型大小会用来计算如偏移量等，0无法被除

20. C++空类默认函数
    
21. 移动构造函数和拷贝构造函数区别
    1. 拷贝构造函数所做的是深拷贝，就是a拷贝到b中，需要在b中首先开辟一片空间在将a中的内容复制过去
    2. 移动构造函数干的是浅拷贝，就是将a中的指针直接复制到b中，同时要将a中的指针指向的位置改变。

22. 一个对象调用 move 转移资源所有权后，再调用这个对象会发生什么情况，
    1. move本身不对对象做任何事，只是单纯的转成右值
    2. 对对象转移资源控制权后，对象并未析构，当其离开作用域时才进行析构
    3. 如果继续使用str2的m_data变量，可能会发生意想不到的错误。：所以要在移动后将其赋空值。

23. 除了用引用，如何在函数传参时避免拷贝

24. 什么是抽象类，作用
    1. 抽象类不能实例化出对象，描述的事物没有对应的实体，另外抽象类体现出了接口继承的关系。

25. **类的const成员变量必须在构造函数的参数初始化列表中进行初始化。**

26. 友元
    1. 友元是一种**定义在类外部的普通函数**，但它需要***\*在类体内进行声明\****，为了与该类的成员函数加以区别，在***\*声明时前面加以关键字friend\****。**友元不是成员函数，但是它可以访问类中的私有成员**。友元的作用在于提高程序的运行效率，但是，**它破坏了类的封装性和隐藏性**，使得非成员函数可以访问类的私有成员。
    2. 什么时候使用友元函数
       运算符重载的某些场合需要友元
       两个类共享数据时

29. ### this 指针

    1. `this` 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。
    2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 `this` 指针。
    3. 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
    4. `this` 指针被隐含地声明为: `ClassName *const this`，这意味着不能给 `this` 指针赋值；在 `ClassName` 类的 `const` 成员函数中，`this` 指针的类型为：`const ClassName* const`，这说明不能对 `this` 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
    5. `this` 并不是一个常规变量，而是个右值，所以不能取得 `this` 的地址（不能 `&this`）。
    6. 在以下场景中，经常需要显式引用this指针：
       1. 为实现对象的链式引用；
       2. 为避免对同一对象进行赋值操作；
       3. 在实现一些数据结构时，如 `list`。
    
30. widget w2 ;   widget w1 = w2； w1 = w2;

31. 访问控制符有哪些，什么区别：

32. 

33. 

34. 

31. 