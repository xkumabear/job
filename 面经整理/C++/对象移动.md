左值：可以**明确其存放地址的值**，更确切说对其的使用是基于地址的

右值：

​	纯右值：比如常量，表达式值a+b
​	将亡值：比如函数传值返回，表达式的中间结果。顾名思义，将亡值的空间马上就要被释放了。

区别：

-  左值可以寻址，而右值不可以。
- 左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。 **右值的生命周期很短**
-  左值可变,右值不可变

#### 左值引用和右值引用

1. 声明的同时必须被初始化
2.  **右值引用：** 表示移动语义-> 目的**避免无意义的拷贝赋值操作**   本质是接替右值的所有权

源码STL中的，[vector](https://so.csdn.net/so/search?q=vector&spm=1001.2101.3001.7020)的扩容使用到了右值引用来提高效率：

左值引用和右值引用作为函数参数都能**避免对象的拷贝和构造**。

### 重点：形参总是左值，即使 其型别是右值。

实际上std::move就是一个类型转换器，将左值转换成右值而以。

```c++
template <typename T>
typename remove_reference<T>::type&& move(T&& t)
{
    return static_case<typename remove_reference<T>::type&&>(t);
}
```

### 万能引用：

代码中有两种类型的通用引用: 一种是auto，另一种是通过模板定义的T&&。实际上auto就是模板中的T，它们是等价的。

不可以有修饰，加上修饰后，就是右值引用。

### 引用折叠

左值引用总是折叠为左值引用，右值引用总是折叠为右值引用。

### 完美转发

std::forward被称为**完美转发**，它的作用是保持原来的`值`属性不变。

第一类其推导时根据的原则是，函数参数传值不影响原值，所以无论你实际传入的参数是普通变量、常量还是引用，它最终都退化为不带任何修修饰的原始类型。

使用场景：按照模板参数的类型，将参数传递给函数模板中调用的另外一个函数。

经std::forward处理后该值还是左值；如果原来的值是右值，经std::forward处理后它还是右值。

```c++
template <typename T>
T&& forward(typename std::remove_reference<T>::type& param)//获得去掉引用的参数类型。
{
    return static_cast<T&&>(param);
}
 
template <typename T>
T&& forward(typename std::remove_reference<T>::type&& param)
{
    return static_cast<T&&>(param);
}

```

右值引用将左值与右值区分开来。它们可以帮助您通过消除不必要的内存分配和复制操作来提高应用程序的性能。它们还使您能够编写接受任意参数的函数的一个版本，并将其转发给另一个函数，就好像直接调用了另一个函数一样