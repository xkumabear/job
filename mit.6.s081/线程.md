## 线程与线程切换

#### 为什么计算机需要运行多线程？

希望他们的计算机在同一时间不是只执行一个任务。希望分时复用。

多线程可以让程序的结构变得简单

使用多线程可以进行并行运算，在拥有多核CPU的计算机上获得更快的处理速度。

线程的概念：

线程可以认为是一种在有多个任务时简化编程的抽象。**一个线程可以认为是串行执行代码的单元**。这是对于线程的一种宽松的定义

线程还具有状态，我们可以随时保存线程的状态并暂停线程的运行，并在之后通过恢复状态来恢复线程的运行。线程的状态包含了三个部分：

- 程序计数器（Program Counter），它表示当前线程执行指令的位置。
- 保存变量的寄存器。
- 程序的Stack（注，详见5.5）。通常来说每个线程都有属于自己的Stack，**Stack记录了函数调用的记录**，并**反映了当前线程的执行点**。

多线程的并行运行主要有两个策略：

- 

  第一个策略是在多核处理器上使用多个CPU，每个CPU都可以运行一个线程，如果你有4个CPU，那么每个CPU可以运行一个线程。每个线程自动的根据所在CPU就有了程序计数器和寄存器。但是如果你只有4个CPU，却有上千个线程，每个CPU只运行一个线程就不能解决这里的问题了。

- 

  二 、一个CPU在多个线程之间来回切换。假设我只有一个CPU，但是有1000个线程，我们接下来将会看到XV6是如何实现线程切换使得XV6能够先运行一个线程，之后将线程的状态保存，再切换至运行第二个线程，然后再是第三个线程，依次类推直到每个线程都运行了一会，再回来重新执行第一个线程。

### vx6中的线程调度

首先线程会运行在所有可用的CPU核上，其次每个CPU核会在多个线程之间切换，因为通常来说，线程数会远远多于CPU的核数。

不同线程系统之间的一个主要的区别就是，线程之间是否会共享内存。

​	XV6**内核共享了内存**，并且XV6**支持内核线程**的概念，对于每个用户进程都有一个内核线程来执行来自用户进程的系统调用。**所有的内核线程都共享了内核内存**，所以XV6的内核线程的确会共享内存。

另一方面，XV6还有另外一种线程。**每一个用户进程都有独立的内存地址空间**（注，详见4.2），并且包含了一个线程，这个线程控制了用户进程代码指令的执行。所以XV6中的用户线程之间没有共享内存，你可以有多个用户进程，但是每个用户进程都是拥有一个线程的独立地址空间。**XV6中的进程不会共享内存。**

在一些其他更加复杂的系统中，例如Linux，允许在一个用户进程中包含多个线程，进程中的多个线程共享进程的地址空间。当你想要实现一个运行在多个CPU核上的用户进程时，你就可以在用户进程中创建多个线程。（xv6中一个进程只有一个线程）

#### 实现内核中的线程系统存在以下挑战：

第一个是如何实现**线程间的切换**。这里**停止一个线程的运行并启动另一个线程的过程通常被称为线程调度**（Scheduling）。**XV6为每个CPU核都创建了一个线程调度器**（Scheduler）。

第二个挑战是，当你想要**实际实现从一个线程切换到另一个线程时，需要保存并恢复线程的状态**，所以需要决定线程的哪些信息是必须保存的，并且在哪保存它们。

最后一个挑战是**如何处理运算密集型线程**（compute bound thread）。对于线程切换，很多**直观的实现是由线程自己自愿的保存自己的状态**，再让其他的线程运行。但是如果我们**有一些程序正在执行一些可能要花费数小时的长时间计算任务，这样的线程并不能自愿的出让CPU给其他的线程运行**。所以这里**需要能从长时间运行的运算密集型线程撤回对于CPU的控制，将其放置于一边，稍后再运行它**。？？？

解决方法 ： 定时器中断  在每个CPU核上，都存在一个硬件设备，它会定时产生中断。XV6与其他所有的操作系统一样，将这个中断传输到了内核中。所以即使我们正在用户空间计算π的前100万位，定时器中断仍然能在例如每隔10ms的某个时间触发，并将程序运行的控制权从用户空间代码切换到内核中的中断处理程序（注，因为中断处理程序优先级更高）。哪怕这些用户空间进程并不配合工作（注，也就是用户空间进程一直占用CPU），内核也可以从用户空间进程获取CPU控制权。

位于内核的**定时器中断处理程序，会自愿的将CPU出让（yield）给线程调度器**，并告诉线程调度器说，你可以让一些其他的线程运行了。这里的出让其实也是一种线程切换，它会保存当前线程的状态，并在稍后恢复。

故基本流程为：定时器中断将CPU控制权给到内核，内核再自愿的出让CPU。即pre-emptive scheduling。抢占式调度 ，pre-emptive的意思是，即使用户代码本身没有出让CPU，定时器中断仍然会将CPU的控制权拿走，并出让给线程调度器。与之相反的是voluntary scheduling。自愿调度

#### 在XV6和其他的操作系统中，线程调度是这么实现的：

**定时器中断会强制的将CPU控制权从用户进程给到内核**，这里是pre-emptive scheduling，之后内核会代表用户进程（注，实际是内核中**用户进程对应的内核线程会代表用户进程出让CPU**），使用voluntary scheduling。



在执行线程调度的时候，操作系统需要能区分几类线程：并分别对应三种线程状态

- 当前在CPU上运行的线程                            **运行态**   ，RUNNING，
- 一旦CPU有空闲时间就想要运行在CPU上的线程         **就绪态**  ，RUNABLE
- 以及不想运行在CPU上的线程，因为这些线程可能在等待I/O或者其他事件         **阻塞态**  ， SLEEPING，

对于RUNNING状态下的线程，它的程序计数器和寄存器位于正在运行它的CPU硬件中。而RUNABLE线程，因为并没有CPU与之关联，所以对于每一个RUNABLE线程，当我们将它从RUNNING转变成RUNABLE时，我们需**要将它还在RUNNING时位于CPU的状态拷贝到内存中的某个位置**，注意这里不是从内存中的某处进行拷贝，而是从CPU中的寄存器拷贝。我们需要拷贝的信息就是程序计数器（Program Counter）和寄存器。



我们从一个正在运行的用户空间进程切换到另一个RUNABLE但是还没有运行的用户空间进程的更完整的流程是：

1. 首先与我之前介绍的一样，一个定时器中断强迫CPU从用户空间进程切换到内核，trampoline代码将用户寄存器保存于用户进程对应的trapframe对象中；
2. 之后在内核中运行usertrap，来实际执行相应的中断处理程序。这时，CPU正在进程P1的内核线程和内核栈上，执行内核中普通的C代码；
3. 假设进程P1对应的内核线程决定它想出让CPU，它会做很多工作，这个我们稍后会看，但是最后它会调用swtch函数（译注：switch 是C 语言关键字，因此这个函数命名为swtch 来避免冲突），这是整个线程切换的核心函数之一；
4. swtch函数会保存用户进程P1对应内核线程的寄存器至context对象。所以**目前为止有两类寄存器：用户寄存器存在trapframe中，内核线程的寄存器存在context中。**



出让CPU是由用户发起的还是由内核发起的？

内核会在两个场景下出让CPU。当定时器中断触发了，内核总是会让当前进程出让CPU，因为我们需要在定时器中断间隔的时间点上交织执行所有想要运行的进程。另一种场景就是任何时候一个进程调用了系统调用并等待I/O，例如等待你敲入下一个按键，在你还没有按下按键时，等待I/O的机制会触发出让CPU。

每一个CPU的调度器线程有自己的栈吗？

是的，每一个调度器线程都有自己独立的栈。实际上调度器线程的所有内容，包括栈和context，与用户进程不一样，都是在系统启动时就设置好了。如果你查看XV6的start.s文件，你就可以看到为每个CPU核设置好调度器线程。

学生提问：context保存在哪？

Robert教授：每一个内核线程都有一个context对象。但是内核线程实际上有两类。每一个用户进程有一个对应的内核线程，它的context对象保存在用户进程对应的proc结构体中。

每一个调度器线程，它也有自己的context对象，但是它却没有对应的进程和proc结构体，所以调度器线程的context对象保存在cpu结构体中。在内核中，有一个cpu结构体的数组，每个cpu结构体对应一个CPU核，每个结构体中都有一个context字段。