## malloc 是如何分配内存的？

实际上，malloc() 并不是系统调用，而是 C 库里的函数，用于动态分配内存。

malloc 申请内存的时候，会有两种方式向操作系统申请堆内存。

- 方式一：通过 brk() 系统调用**从堆分配内存**
  - 就是通过 brk() 函数将「堆顶」指针向高地址移动，获得新的内存空间。###

- 方式二：通过 mmap() 系统调用在文件映射区域分配内存；
  - 方式二通过 mmap() 系统调用中「私有匿名映射」的方式，在文件映射区分配一块内存，也就是从文件映射区“偷”了一块内存。#

malloc() 源码里默认定义了一个阈值：

- 如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；
- 如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；

**malloc() 分配的是虚拟内存**。分配后的虚拟内存没有被访问的话，虚拟内存是不会映射到物理内存的，这样就不会占用物理内存了。（懒汉模式）

在访问已分配的虚拟地址空间的时候，操作系统通过查找页表，发现虚拟内存对应的页没有在物理内存中，就会触发缺页中断，然后操作系统会建立虚拟内存和物理内存之间的映射关系。

#### malloc(1) 会分配多大的虚拟内存？

malloc() 在分配内存的时候，并不是老老实实按用户预期申请的字节数来分配内存空间大小，而是**会预分配更大的空间作为内存池**。

#### free 释放内存，会归还给操作系统吗？###

与其把这 1 字节释放给操作系统，不如**先缓存着放进 malloc 的内存池里，当进程再次申请 1 字节的内存时就可以直接复用**，这样速度快了很多。

当进程退出后，操作系统就会回收进程的所有资源。

 free 内存后堆内存还存在，是针对 malloc 通过 brk() 方式申请的内存的情况。

如果 malloc 通过 mmap 方式申请的内存，free 释放内存后就会归归还给操作系统。

##### 为什么不全部使用 mmap 来分配内存？

1. ##### buddy算法：解决内存的外碎片。

2. buddy算法将所有空闲页框分组为10个块链表，每个块链表的每个块元素分别包含1,2,4,8,16,32,64,128,256,512个连续的页框，每个块的第一个页框的物理地址是该块大小的整数倍。如，大小为16个页框的块，其起始地址是16*2^12(一个页框的大小为4k,16个页框的大小为16*4K,1k=1024=2的10次方，4k=2的12次方)的倍数。
   例，假设要请求一个128个页框的块，算法先检查128个页框的链表是否有空闲块，如果没有则查256个页框的链表，有则将256个页框的块分裂两份，一份使用，一份插入128个页框的链表。如果还没有，就查512个页框的链表，有的话就分裂为128，128，256，一个128使用，剩余两个插入对应链表。如果在512还没查到，则返回出错信号。

3. 回收时执行相反操作