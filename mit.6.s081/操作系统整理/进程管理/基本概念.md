进程：**运行中的程序，就被称为「进程」**

并发：它可能会运行多个进程，这样就产生**并行的错觉**，实际上这是**并发**。宏观上

![并发与并行](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/5-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C.jpg)![进程五种状态的变迁](https://cd



![七种状态变迁](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/10-%E8%BF%9B%E7%A8%8B%E4%B8%83%E4%B8%AD%E7%8A%B6%E6%80%81.jpg)

在虚拟内存管理的操作系统中，通常会把阻塞状态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换入到物理内存。**描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态**。这跟阻塞状态是不一样，阻塞状态是等待某个事件的返回。

挂起状态可以分为两种：

- 阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；
- 就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；

### 进程的控制结构

操作系统中，是用**进程控制块**（*process control block，PCB*）数据结构来描述进程的。“

1. **进程描述信息：**
   - 进程标识符
   - 用户标识符
2. **进程控制和管理信息：**
   - 进程当前状态
   - 进程优先级
3. **资源分配清单：**
   1. 有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。
4. **CPU 相关信息：**
   1. CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。trapframe 和 context

xv6中还包含 父进程的pcb指针，用户态页表，内核栈指针，进程切换时的内核上下文信息，

PCB 是如何组织的呢？

通常是通过**链表**的方式进行组织，把具有**相同状态的进程链在一起，组成各种队列**。比如：

- 将所有处于就绪状态的进程链在一起，称为**就绪队列**；
- 把所有因等待某事件而处于等待状态的进程链在一起就组成各种**阻塞队列**；
- 另外，对于运行队列在单核 CPU 系统中则只有一个运行指针了，因为单核 CPU 在某个时间，只能运行一个程序。

xv6中为一个索引数组。

**01 创建进程**

**02 终止进程**

进程可以有 3 种终止方式：正常结束、异常结束以及外界干预（信号 `kill` 掉）。

当子进程被终止时，其在父进程处继承的资源应当还给父进程。而当父进程被终止时，该父进程的子进程就变为孤儿进程，会被 1 号进程收养，并由 1 号进程对它们完成状态收集工作。

终止进程的过程如下：

- 查找需要终止的进程的 PCB；
- 如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程；
- 如果其还有子进程，则应将该进程的子进程交给 1 号进程接管；
- 将该进程所拥有的全部资源都归还给操作系统；
- 将其从 PCB 所在队列中删除；

**03 阻塞进程**

sleep wakeup

**04 唤醒进程**

#### 上下文切换

把 CPU 上下文切换分成：**进程上下文切换、线程上下文切换和中断上下文切换**。

**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。**

把交换的信息保存在进程的 PCB

发生场景： 时钟中断，硬件中断，资源不足无法运行时，阻塞某个事件而sleep，高优先级的进程加入队列。

##### 线程的上下文切换：

线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。

看线程是不是属于同一个进程：

- 当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；
- **当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据**；

#### 多进程存在的问题：

- 进程之间如何通信，共享数据？
- 维护进程的系统开销较大，如创建进程时，分配资源、建立 PCB；终止进程时，回收资源、撤销 PCB；进程切换时，保存当前进程的状态信息； 优化策略：cow lazy 

需要：实体之间可以并发运行；实体之间共享相同的地址空间；↓

**线程是进程当中的一条执行流程。**

同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套**独立的寄存器和栈**，这样可以确保线程的控制流是相对独立的。

线程的优点：

- 一个进程中可以同时存在多个线程；
- 各个线程之间可以并发执行；
- 各个线程之间可以共享地址空间和文件等资源；

线程的缺点：

- 当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃

### 线程与进程的比较

线程与进程的比较如下：

- 进程是**资源（包括内存、打开的文件等）分配的单位**，线程是 CPU 调度的单位；
- **进程拥有一个完整的资源**平台，而**线程只独享必不可少的资源**，如寄存器和栈；
- **线程同样具有就绪、阻塞、执行三种基本状态**，同样具有状态之间的转换关系；
- **线程能减少并发执行的时间和空间开销**；

对于，线程相比进程能减少开销，体现在：

- **线程的创建时间比进程快**，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；
- **线程的终止时间比进程快**，因为线程释放的资源相比进程少很多；
- **同一个进程内的线程切换比进程切换快**，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；
- 由于同一进程的各线程间**共享内存和文件资源**，那么**在线程之间数据传递的时候，就不需要经过内核了**，这就使得线程之间的数据交互效率更高了；

### 线程的实现：

- **用户线程（\*User Thread\*）**：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；
  - 优点：用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换
  - 缺点：如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了
    - 当一个线程开始运行后，除非它主动地交出 CPU 的使用权，否则它所在的进程当中的其他线程无法运行，因为用户态的线程没法打断当前运行中的线程。
- **内核线程（\*Kernel Thread\*）**：在内核中实现的线程，是由内核管理的线程；
  - **优点**：
    - 在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；
    - 分配给线程，多线程的进程获得更多的 CPU 运行时间；
  - **缺点**：
    - 在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB；
    - 线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大；
- **轻量级进程（\*LightWeight Process\*）**：在内核中来支持用户线程；
  - **一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的**
  - m:n:综合了前两种优点，大部分的线程上下文发生在用户空间，且多个线程又可以充分利用多核 CPU 的资源。

线程的对应关系：

用户线程是基于用户态的线程管理库来实现的，对于操作系统而言是看不到这个 TCB 的，它只能看到整个进程的 PCB。

所以，**用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。**