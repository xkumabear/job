# 悲观锁、乐观锁

##### 「**互斥锁、自旋锁、读写锁、乐观锁、悲观锁**」的选择和使用？

#### 互斥锁与自旋锁

互斥锁和自旋锁对于加锁失败后的处理方式不一样

- **互斥锁**加锁失败后，线程会**释放 CPU** ，给其他线程；（睡眠锁） 存在**两次线程上下文切换的成本**开销
- **自旋锁**加锁失败后，线程会**忙等待**，直到它拿到锁；

**如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。**

**当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对**。

#### 读写锁

**读写锁适用于能明确区分读操作和写操作的场景**。

- 当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。
- 但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。

**读写锁在读多写少的场景，能发挥出优势**。

写优先锁」是优先服务写线程：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取写锁。

## 乐观锁与悲观锁

互斥锁、自旋锁、读写锁，都是属于悲观锁。

悲观锁：**多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁**。

乐观锁：**先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作**。

**乐观锁全程并没有加锁，所以它也叫无锁编程**。

简单实现，通过记录并验证版本号来确认是否更新成果。

**只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。** 如git

乐观锁是先修改同步资源，再验证有没有发生冲突。

悲观锁是修改共享数据前，都要先加锁，防止竞争。